<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/mdavila_2001/tripadvisorclonemarcelodavila/ui/viewmodels/TripDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/mdavila_2001/tripadvisorclonemarcelodavila/ui/viewmodels/TripDetailViewModel.kt" />
              <option name="originalContent" value="package com.mdavila_2001.tripadvisorclonemarcelodavila.ui.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.data.remote.models.Place&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.data.remote.network.RetroFitInstance&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.data.repositories.PlaceRepository&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.utils.SessionManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asSharedFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class TripDetailUiState (&#10;    val isLoading: Boolean = true,&#10;    val places: List&lt;Place&gt; = emptyList(),&#10;    val isMyTrip: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class TripDetailViewModel(&#10;    application: Application,&#10;    private val tripId: Int,&#10;    private val tripOwner: String&#10;): AndroidViewModel(application) {&#10;    private val repository = PlaceRepository(RetroFitInstance.api)&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    private val _uiState = MutableStateFlow(TripDetailUiState())&#10;    val uiState: StateFlow&lt;TripDetailUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Evento que indica que un lugar fue eliminado correctamente&#10;    private val _deleteSuccess = MutableSharedFlow&lt;Boolean&gt;(replay = 0)&#10;    val deleteSuccess = _deleteSuccess.asSharedFlow()&#10;&#10;    init {&#10;        loadPlaces()&#10;    }&#10;&#10;    private fun loadPlaces() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;&#10;            val currentUser = sessionManager.getUserName()&#10;            val isMyTrip = (currentUser == tripOwner)&#10;&#10;            var errorMsg: String? = null&#10;            var places: List&lt;Place&gt; = emptyList()&#10;&#10;            try {&#10;                val response = repository.getPlacesByTrip(tripId)&#10;                if (response.isSuccessful) {&#10;                    places = response.body() ?: emptyList()&#10;                    Log.d(&quot;DEBUG_IMAGEN&quot;, &quot;Datos de imagen recibidos: ${places.firstOrNull()?.imageUrl}&quot;)&#10;                } else {&#10;                    errorMsg = &quot;Error al cargar lugares: ${response.code()}&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                errorMsg = &quot;Error al cargar lugares: ${e.message}&quot;&#10;            }&#10;&#10;            _uiState.update {&#10;                it.copy(&#10;                    isLoading = false,&#10;                    places = places,&#10;                    isMyTrip = isMyTrip,&#10;                    errorMessage = errorMsg&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onDeletePlace(place: Place) {&#10;        viewModelScope.launch {&#10;            _uiState.update {&#10;                it.copy(isLoading = true)&#10;            }&#10;&#10;            try {&#10;                val response = repository.deletePlace(place.id)&#10;&#10;                if (response.isSuccessful) {&#10;                    // Emitir evento de éxito para que la UI muestre un Toast&#10;                    _deleteSuccess.emit(true)&#10;                    loadPlaces()&#10;                } else {&#10;                    _uiState.update { it.copy(errorMessage = &quot;Error al eliminar: ${response.message()}&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.mdavila_2001.tripadvisorclonemarcelodavila.ui.viewmodels&#10;&#10;import android.app.Application&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.data.remote.models.Place&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.data.remote.network.RetroFitInstance&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.data.repositories.PlaceRepository&#10;import com.mdavila_2001.tripadvisorclonemarcelodavila.utils.SessionManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.asSharedFlow&#10;import kotlinx.coroutines.launch&#10;&#10;data class TripDetailUiState (&#10;    val isLoading: Boolean = true,&#10;    val places: List&lt;Place&gt; = emptyList(),&#10;    val isMyTrip: Boolean = false,&#10;    val errorMessage: String? = null&#10;)&#10;&#10;class TripDetailViewModel(&#10;    application: Application,&#10;    private val tripId: Int,&#10;    private val tripOwner: String&#10;): AndroidViewModel(application) {&#10;    private val repository = PlaceRepository(RetroFitInstance.api)&#10;    private val sessionManager = SessionManager(application)&#10;&#10;    private val _uiState = MutableStateFlow(TripDetailUiState())&#10;    val uiState: StateFlow&lt;TripDetailUiState&gt; = _uiState.asStateFlow()&#10;&#10;    // Evento que indica que un lugar fue eliminado correctamente&#10;    private val _deleteSuccess = MutableSharedFlow&lt;Boolean&gt;(replay = 0)&#10;    val deleteSuccess = _deleteSuccess.asSharedFlow()&#10;&#10;    init {&#10;        loadPlaces()&#10;    }&#10;&#10;    private fun loadPlaces() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;&#10;            val currentUser = sessionManager.getUserName()&#10;            val isMyTrip = (currentUser == tripOwner)&#10;&#10;            var errorMsg: String? = null&#10;            var places: List&lt;Place&gt; = emptyList()&#10;&#10;            try {&#10;                val response = repository.getPlacesByTrip(tripId)&#10;                if (response.isSuccessful) {&#10;                    places = response.body() ?: emptyList()&#10;                    Log.d(&quot;DEBUG_IMAGEN&quot;, &quot;Datos de imagen recibidos: ${places.firstOrNull()?.imageUrl}&quot;)&#10;                } else {&#10;                    errorMsg = &quot;Error al cargar lugares: ${response.code()}&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                errorMsg = &quot;Error al cargar lugares: ${e.message}&quot;&#10;            }&#10;&#10;            _uiState.update {&#10;                it.copy(&#10;                    isLoading = false,&#10;                    places = places,&#10;                    isMyTrip = isMyTrip,&#10;                    errorMessage = errorMsg&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onDeletePlace(place: Place) {&#10;        viewModelScope.launch {&#10;            _uiState.update {&#10;                it.copy(isLoading = true)&#10;            }&#10;&#10;            try {&#10;                val response = repository.deletePlace(place.id)&#10;&#10;                if (response.isSuccessful) {&#10;                    // Emitir evento de éxito para que la UI muestre un Toast&#10;                    _deleteSuccess.emit(true)&#10;                    loadPlaces()&#10;                } else {&#10;                    _uiState.update { it.copy(errorMessage = &quot;Error al eliminar: ${response.message()}&quot;) }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { it.copy(errorMessage = &quot;Error de conexión: ${e.message}&quot;) }&#10;            }&#10;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>